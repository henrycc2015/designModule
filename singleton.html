<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>singleton</title>
    <meta name="viewport" content="width=device-width, initial-scale=1">
    <link rel="stylesheet" type="text/css" href="design.css" media="screen">
    <script type="text/javascript" src="jquery-2.2.4.min.js"></script>
</head>
<body>
    <!--<div id="singleton">-->
        <!--单例模式-->
    <!--</div>-->
    <!--<ul class="inform">-->

        <!--<li>-->
            <!--1、方法单独创建一个函数,通过回调函数的方式传入到singleton包装-->
        <!--</li>-->
        <!--<li>-->
            <!--2、用一个变量来保存第一次的返回值,如果被赋过值了,那么以后的调用中优先返回该变量。-->
        <!--</li>-->
    <!--</ul>-->

    <!--<div id="factory">-->
        <!--工厂模式-->
    <!--</div>-->
    <!--<ul class="inform">-->

        <!--<li>-->
            <!--1、用一个方法来决定创建哪个类的实例-->
        <!--</li>-->
        <!--<li>-->
            <!--2、执行时决定创建的是什么,因为它们往往有相同的接口-->
        <!--</li>-->
    <!--</ul>-->

    <!--<div id="observer">-->
        <!--观察者模式-->
    <!--</div>-->
    <!--<ul id = 'obInform'class="inform">-->
        <!--<li>-->
            <!--1、最常用的模式之一,平时接触的dom事件,是js和dom之间实现的一种观察者模式-->
        <!--</li>-->
        <!--<li>-->

            <!--2、观察者模式可以很好的实现2个模块之间的解耦。-->
        <!--</li>-->
        <!--<li>-->
            <!--3、具体实现:面试者把简历扔到一个盒子里,然后面试官在合适的时机拿着盒子里的简历挨个打电话通知结果-->
        <!--</li>-->
    <!--</ul>-->
    <!--<div id="adapter">适配器</div>-->
    <!--<ul class="inform">-->
        <!--<li>适配器模式像一个转接口,经常用来适配两个接口</li>-->
    <!--</ul>-->
    <!--<div id="agent">代理模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、对一个对象的访问交给另一个代理对象来操作</li>-->
        <!--<li>2、例如,频繁访问dom节点,频繁请求远程资源,可以把操作先缓存到一个缓冲区,选择真正的触发时机</li>-->
        <!--<li>3、ajax请求,都会给xhr对象设置一个代理. 我们不可能频繁的去操作xhr对象发请求, 而应该是这样.</li>-->
    <!--</ul>-->
    <!--<div id="bridge">-->
        <!--桥接模式-->
    <!--</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、桥接模式一般有抽象部分和实现部分</li>-->
        <!--<li>2、完全独立互不影响</li>-->
    <!--</ul>-->

    <!--<div id="visitor">访问者模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、访问者模式是表示一个作用于某个对象结构中的各元素的操作。它使可以在不改变各元素的前提下定义作用于这些元素的新操作。</li>-->
        <!--<li>2、我们在使用一些操作对不同的元素进行处理时,往往会根据不同的对象选择不同的处理方法和过程。</li>-->
        <!--<li>3、在实际的代码过程中,我们可以发现,如果让所有的操作分散到各个对象中,整个系统会变得难以维护和修改。且增加新的操作通常需要重新编译。</li>-->
        <!--<li>4、因此,我们可以将每个类中的相关操作提取出来,包装成一个独立的对象。 这个对象就叫访问者。利用访问者,对访问的元素进行某些操作时,只需将此对象作为参数传递给当前访问者,然后,访问者会依据被访问者的具体信息,进行相关操作。</li>-->
    <!--</ul>-->
    <!--<div id="strategy">策略模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、意义在于 定义一系列的算法,把他们一个个封装起来,并且使它们可相互替换</li>-->
        <!--<li>2、比如验证表单,表单的每个成员都会有一些不同的验证规则,如果表单里面的元素多一些,需要校验的情况比较多,写很多if else 是不合理的</li>-->
        <!--<li>3、所以更好的做法是把每一种验证规则都用策略模式单独封装起来。</li>-->
    <!--</ul>-->
    <!--<div id="modules">模版方法模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、先把算法的不变部分抽象到父类,再将一些可变的步骤延迟到子类实现</li>-->
        <!--<li>2、和工厂模式最大的区别在于:工厂模式意图是根据子类的实现最终获得一种对象,模版模式着重于父类对子类的控制</li>-->
        <!--<li>3、模版方法导致一种反向的控制结构,"别找我们,我们找你。"</li>-->
    <!--</ul>-->

    <!--<div id="Medium">中介者模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、中介者对象可以让各个对象之间不需要显示的相互引用,从而使其耦合松散,而且可以独立的改变他们之间的交互</li>-->
        <!--<li>2、银行在贷款和存款者之间,充当了中介者对象的角色</li>-->
        <!--<li>3、MVC框架中的controller充当中介者的角色</li>-->
    <!--</ul>-->
    <!--<div id="composite">组合模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、部分-整体模式</li>-->
        <!--<li>2、操作最上层的接口,就可以对所有的成员做相同的操作</li>-->
    <!--</ul>-->
    <!--<div id="memo">备忘录模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、备忘录模式在js中经常用于数据缓存,比如一个分页控件</li>-->
        <!--<li>2、从服务器获得某一页的数据后可以存入缓存</li>-->
    <!--</ul>-->
    <!--<div id="responsibilityChain">责任链模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、js中的事件冒泡就是作为一个责任链来实现的。一个事件在某个节点上被触发,然后向根节点传递,直到被节点捕获</li>-->
    <!--</ul>-->
    <!--<div id="share">责任链模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、享元模式主要用来减少程序所需的对象个数</li>-->
    <!--</ul>-->
    <!--<div id="state">责任链模式</div>-->
    <!--<ul class="inform">-->
        <!--<li>1、一个对象的行为取决于它的状态</li>-->
        <!--<li>2、一个操作中含有庞大的条件分支语句</li>-->
        <!--<li>3、通过一个状态类,把散落在世界各地的条件分支集中管理到一个类中</li>-->
    <!--</ul>-->
    <input id='pub1'type="button" value="发布者1"> <input id='pub11' type="text"><br/>
    <input id='pub2'type="button" value="发布者2"> <input id='pub12' type="text"><br/>
    <input id='pub3'type="button" value="发布者3"> <input id='pub13' type="text"><br/>

    <textarea id="sub1"></textarea>
    <textarea id="sub2"></textarea>
</body>
<script harmony=true" src="design.js" ></script>
</html>